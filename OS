#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "wrapper.h"
#include "timeft.h"
#include <math.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <pthread.h>

typedef struct {
  double **data1;
  double **data2;
  double **data3;
  int n, start, end;
} thread_arg;

void *matrix_mult(void *arg){
  thread_arg *t = (thread_arg *)arg;
  int n = t->n;
  int start = t->start;
  int end = t->end;
  double **data1 = t->data1;
  double **data2 = t->data2;
  double **data3 = t->data3;

  for (int k = start; k <= end ;k++){
    for (int j = 0; j < n; j++) {
      data3[k][j] = 0;
      for (int m = 0; m < n; m++) {
        data3[k][j] += data1[k][m] * data2[m][j];
      }
    }	
  }
  return NULL;
}

int main(int argc, char *argv[])
{
  int ifd1, ifd2, ofd, n, p;
  double **data1, **data2, **data3;
  struct stat st1;
  struct stat st2;

  
  if (argc != 5){
    perror("Usage: ./hw3 infile1 infile2 outfile <t>");
    return 1;
  }
  Stat(argv[1], &st1);
  n = sqrt(st1.st_size / sizeof(double));
  if(st1.st_size != n*n*sizeof(double)){
    perror("Error: The 1st input file size is not n*n");
    return 1;
  }
  Stat(argv[2], &st2);
  if(st2.st_size != st1.st_size){
    perror("Error: The 2nd input file size is not the same as the 1st one");
    return 1;
  }
  if (atoi(argv[4]) <= 0){
    perror("Error: The 4th parameter should be an integer greater than zero");
    return 1;
  }
  if (atoi(argv[4]) > n){
    p = n;
  }
  else {
    p = atoi(argv[4]);
  }
  ifd1 = Open(argv[1], O_RDONLY);
  data1 = (double **) malloc(n * sizeof(double *));
  for (int i = 0; i < n; i++) {
    data1[i] = (double *) malloc(n * sizeof(double));
    for (int j = 0; j < n; j++) {
      read(ifd1, &data1[i][j], sizeof(double));
    }
  }
  close(ifd1);
  ifd2 = Open(argv[2], O_RDONLY);
  data2 = (double **) malloc(n * sizeof(double *));
  for (int i = 0; i < n; i++) {
    data2[i] = (double *) malloc(n * sizeof(double));
    for (int j = 0; j < n; j++) {
      read(ifd2, &data2[i][j], sizeof(double));
    }
  }
  close(ifd2); 
  data3 = (double **) malloc(n * sizeof(double *));
  for (int i = 0; i < n; i++) {
    data3[i] = (double *) malloc(n * sizeof(double));
  }

  pthread_t *threads;
  thread_arg *targs;
  threads = (pthread_t *) malloc(p * sizeof(pthread_t));
  targs = (thread_arg *) malloc(p * sizeof(thread_arg));
  int size = ceil(n/p);
  init_timelog(1);

  for (int i = 0; i < p; i++) {
    targs[i].data1 = data1;
    targs[i].data2 = data2;
    targs[i].data3 = data3;
    targs[i].n = n;
    targs[i].start = i * size;
    targs[i].end = (i+1) * size - 1;
    if (i == p-1){
      targs[i].end = n-1;
    }
    start_timelog(0);
    Pthread_create(&threads[i], NULL, matrix_mult, &targs[i]);
  }

  for (int i = 0; i < p; i++) {
    pthread_join(threads[i], NULL);
    finish_timelog(0);
  }
  
  close_timelog();
  
  ofd = Creat(argv[3], 0644) ;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      write(ofd, &data3[i][j], sizeof(double));
    }
  }
  close(ofd);
  return 0;
}
