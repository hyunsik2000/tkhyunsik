#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char name[256];
    off_t size;
} mydata_t;

int compare_file_info(const void *a, const void *b) {
    const mydata_t *fileInfoA = (const mydata_t *)a;
    const mydata_t *fileInfoB = (const mydata_t *)b;
    return (fileInfoB->size - fileInfoA->size);
}

int myGetFNList(mydata_t *list, int arrsize) {
    DIR *dirp;
    struct dirent *dentry;
    struct stat finfo;
    int numFiles = 0;

    dirp = opendir(".");
    if (dirp == NULL) {
        perror("opendir");
        return -1; 
    }

    while ((dentry = readdir(dirp)) != NULL) {
        if (stat(dentry->d_name, &finfo) == -1) {
            perror("stat");
            continue;
        }
        if (!S_ISDIR(finfo.st_mode) && S_ISREG(finfo.st_mode)) {
            if (numFiles < arrsize) {
                strncpy(list[numFiles].name, dentry->d_name, sizeof(list[numFiles].name) - 1);
                list[numFiles].name[sizeof(list[numFiles].name) - 1] = '\0'; 
                list[numFiles].size = finfo.st_size;
                numFiles++;
            } else {
                break;
            }
        }
    }

    closedir(dirp);

    if (numFiles > 0) {
        qsort(list, numFiles, sizeof(mydata_t), compare_file_info);

        for (int i = 0; i < numFiles; i++) {
            printf("%s %ld\n", list[i].name, list[i].size);

            char new_name[256];
            snprintf(new_name, sizeof(new_name), "%02d-%s", i + 1, list[i].name);
            if (rename(list[i].name, new_name) != 0) {
                perror("rename");
            }
        }
    } else {
        printf("No files found.\n");
    }

    return numFiles;
}

int main(void) {

    mydata_t *fileInfos = (mydata_t *)malloc(100 * sizeof(mydata_t));  

    if (fileInfos == NULL) {
        perror("malloc");
        return 1;
    }

    int numFiles = myGetFNList(fileInfos, 100);

    free(fileInfos);
    return 0;
}
